### **“影梭”第一阶段：分模块开发提示词**

以下是为AI助手（VibeCoding模式）或开发团队准备的、基于技术规格说明书的分模块开发提示词。每个提示词均包含明确的**角色**、**任务**、**输入**、**处理逻辑**、**输出**及**验收标准**。

---

#### **模块 M1：部署 Headscale 协调服务器**

**角色**：DevOps 工程师 / 后端工程师
**任务**：搭建并配置私有的 Mesh 网络协调中心，为设备发现和安全隧道建立提供基础设施。
**技术栈**：Docker, Headscale, 任意云服务器 (Ubuntu 22.04 LTS)
**输入**：一台全新的云服务器实例，拥有公网IP和root权限。
**处理**：
1.  SSH登录服务器，安装 Docker 和 Docker Compose。
2. 创建 `docker-compose.yml` 文件，部署 Headscale 容器，并配置：
    *   将 `HEADSCALE_SERVER_URL` 设置为服务器的公网域名或IP。
    *   将 `HEADSCALE_OIDC_ISSUER` 配置为 `https://github.com`（使用GitHub OAuth示例）。
    *   配置一个基础的ACL策略文件，允许同一命名空间下的所有节点互通。
3. 启动容器，并在服务器防火墙开放必要的端口（默认 8080）。
4. 在 GitHub Developer Settings 中创建一个 OAuth App，将回调地址设置为 `HEADSCALE_SERVER_URL/oidc/callback`。
5. 验证通过Web浏览器能访问Headscale控制台，并能用GitHub账号登录。
**输出**：一个正在运行的 Headscale 服务实例，可通过 `https://your-server.com` 访问其控制台和管理API。
**验收标准**：
*   AC1: 执行 `headscale --server http://localhost:8080 nodes list` 命令能返回结果（初始为空列表）。
*   AC2: 在浏览器中打开服务地址，能用GitHub账号成功登录并看到控制台界面。

---

#### **模块 M2：开发电脑守护进程 (`shadowd`)**

**角色**：后端工程师 (Go)
**任务**：开发一个能自动加入Mesh网络，并提供SSH与gRPC访问接口的常驻系统守护进程。
**技术栈**：Go, Tailscale client library (`tailscale.com/client`), `gliderlabs/ssh`, gRPC-Web
**输入**：无（系统服务自启动）。
**处理**：
1.  **初始化与网络接入**：
    *   程序启动时，从配置文件或环境变量读取 `HEADSCALE_AUTH_KEY`（一次性预认证密钥）。
    *   调用 `tailscale.IgnoreMacOSMajorVersionCheck()` 并初始化客户端，使用上述AuthKey连接到指定的Headscale服务器。
    *   等待连接成功，并打印获取到的Mesh IP（如 `100.101.102.103`）。
2.  **暴露SSH服务**：
    *   使用 `gliderlabs/ssh` 库启动一个SSH服务器。
    *   **关键安全约束**：服务器必须**仅监听**在 `tailscale.LocalClient().TailscaleIP()` 返回的Mesh IP地址上，**而不是** `0.0.0.0`。
    *   配置SSH主机密钥和公钥认证方式（认证逻辑可初始化为接受任何配对过的密钥，后续与M3模块联动）。
3.  **暴露gRPC-Web服务**：
    *   在 `localhost:8080` 启动一个gRPC-Web服务器。
    *   实现 `ShadowService` 服务，包含 `GetSystemInfo` (返回主机名、操作系统) 和 `ExecuteSimpleCommand` (暂时可只处理 `"lock"` 命令) 两个RPC方法。
4.  **生成配对二维码**（CLI功能）：
    *   实现 `--generate-qr` 命令行标志。当设置时，程序生成一个包含随机临时Token和本机主机名的URL（格式：`shadow://pair?token=xyz&hostname=mypc`），并以ASCII艺术形式在控制台打印二维码。
**输出**：一个可执行的Go二进制文件 `shadowd`。作为系统服务运行时，它提供：
*   一个在Mesh IP上的SSH（22端口）服务。
*   一个在 `localhost:8080` 的gRPC-Web服务。
*   一个用于生成配对二维码的CLI命令。
**验收标准**：
*   AC2.1: 在Headscale控制台能看到运行 `shadowd` 的电脑节点状态为“在线”。
*   AC2.2: 从同一Mesh网络内的另一台机器，能通过 `ssh <mesh_ip>` 成功连接（需配置对应密钥）。
*   AC2.3: 在本地执行 `curl http://localhost:8080` 能收到gRPC-Web的响应头。
*   AC2.4: 执行 `shadowd --generate-qr` 能在终端正确显示一个二维码。

---

#### **模块 M3：RN - 网络连接、发现与配对**

**角色**：移动端工程师 (React Native)
**任务**：开发RN应用的核心连接与设备管理功能，包括Mesh VPN连接、设备列表获取和扫码配对。
**技术栈**：React Native (TypeScript), Zustand, 原生模块 (iOS/Android), `react-native-camera`
**输入**：用户操作（点击按钮、扫描二维码）。
**处理**：
1.  **子模块 M3.1：构建原生模块 `NativeTailscale`**：
    *   **目标**：创建桥接JS与原生Tailscale Mobile SDK的模块。
    *   **iOS**：创建 `RNTailscaleManager`，封装 `NetworkExtension` API，提供 `connect`, `disconnect`, `getStatus` 方法。
    *   **Android**：创建 `TailscaleModule`，封装 `com.tailscale.ipn`，提供类似方法。
    *   **JS接口**：导出统一的 `connect(authKey): Promise<void>`, `getCurrentIp(): Promise<string>` 等方法。
2.  **子模块 M3.2：连接与设备发现UI**：
    *   **屏幕S1（连接页）**：
        *   UI：一个“连接”按钮，一个显示状态（如“未连接”、“IP: 100.x.x.x”）的文本。
        *   逻辑：点击按钮，调用 `NativeTailscale.connect(<从安全存储读取的AuthKey>)`，连接成功后更新状态。
    *   **屏幕S2（设备列表页）**：
        *   UI：一个FlatList，渲染设备（名称、主机名、“在线”徽章），一个“扫码”FAB按钮。
        *   逻辑：进入页面时，通过已建立的VPN通道，调用 `fetch(<headscale_server>/api/v1/machine)`（携带API密钥），解析并显示“在线”状态的设备。
3.  **子模块 M3.3：扫码配对流程**：
    *   **逻辑**：
        *   用户点击“扫码”按钮，打开相机视图。
        *   扫描到 `shadow://pair?token=xyz&hostname=mypc` 格式的二维码后，解析出 `token` 和 `hostname`。
        *   通过VPN向 `http://<target_mesh_ip>:8080` （gRPC-Web接口）发起一个配对请求（例如 `POST /pair`， body `{token}`）。
        *   收到成功响应后，将 `{hostname, mesh_ip}` 存入 AsyncStorage 或 Zustand store。
**输出**：一个包含三个核心屏幕（S1, S2, 扫码相机）的RN应用，具备完整的VPN连接、设备发现与配对能力。
**验收标准**：
*   AC3.1: 在S1页面能成功点击连接和断开，状态显示正确。
*   AC3.2: 连接后，S2页面能自动列出已在Headscale注册且在线的电脑设备。
*   AC3.3: 使用电脑生成的二维码，能在RN App内完成扫描、验证、并成功将设备添加到本地列表。

---

#### **模块 M4：RN - 专家终端**

**角色**：移动端工程师 (React Native)
**任务**：在RN应用中集成一个SSH终端模拟器，允许用户连接到已配对的电脑并执行命令。
**技术栈**：React Native, `react-native-ssh-sftp`, `react-native-terminal` (或自定义Terminal View组件)
**输入**：用户在设备列表（S2）点击某个电脑设备。
**处理**：
1.  **屏幕S3（终端页）开发**：
    *   **导航**：从S2页导航至S3，并传入参数 `device`（包含 `meshIp`, `hostname`）。
    *   **UI**：顶部栏显示主机名，主体部分为终端输出区域（可滚动的Text组件），底部为命令行输入框。
2.  **SSH连接与会话管理**：
    *   使用 `react-native-ssh-sftp` 库，在屏幕加载时，使用设备的 `meshIp` 和预设的SSH密钥建立连接。
    *   将SSH通道的 `stdout` 和 `stderr` 数据流实时附加到终端输出区域。
    *   将用户在输入框中输入的命令（以换行符结束）通过SSH通道发送。
    *   实现基础的错误处理（如连接断开提示）。
**输出**：一个功能完整的终端屏幕，用户可在此与远程电脑进行交互式命令行操作。
**验收标准**：
*   AC4.1: 从S2页点击设备后，能导航至S3页并成功建立SSH连接（无错误提示）。
*   AC4.2: 在输入框执行 `pwd`、`ls -la` 等命令，能正确在终端输出区域显示结果。
*   AC4.3: 能处理长输出滚动，并能进行基本的命令行编辑（如退格）。

---
**使用说明**：将以上任一模块的“处理”部分内容，直接提供给处于“VibeCoding”或“开发助手”模式的AI，即可获得详细的代码实现、文件结构和技术指导。每个模块均可独立开发。